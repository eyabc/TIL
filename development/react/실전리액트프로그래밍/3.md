3장 리액트 개념
---

# UI 데이터 관리 : 상탯값, 속성값
* 상태값
    * 컴포넌트 내부에서 관리하는 데이터
* 속성값
    * 부모 컴포넌트로부터 전달받은 데이터

* 렌더함수
    * 화면을 그리는 모든 코드 
    
* UI 데이터 변경 -> 리액트는 렌더 함수를 이용해 화면을 자동 갱신함.

## React.memo, React.PureComponent
자식 컴포넌트는 부모 컴포넌트가 렌더링 될 때마다 렌더링 된다.
* 상태값이나 속성값이 변경될 때만 렌더링 되게함.
* 함수형 컴포넌트
    ```javascript
    function Title(props) {
        return <p>{props.title}</p>;
    }
    export default React.memo(Title);
    ```
* 클래스형 컴포넌트
    ```javascript
    export default class Title extends React.PureComponent {
        render() {
            return <p>{props.title}</p>;
        }
    }
    ```
    * 리액트 내부에서 인스턴스로 존재하게 된다.
        * 자신만의 메모리 공간을 갖음.
            * 즉, 같은 컴포넌트라도 자신만의 상태값이 존재함.

## setState
클래스형 컴포넌트에서 상태값을 변경할때 호출하는 메서드
* 비동기로 동작
    ```javascript
        onClick = () => {
            this.setState({ count: this.state.count + 1 });
            this.setState({ count: this.state.count + 1 });
        }
  // 1 증가
    ```
    * 동기 처리의 문제
        * setState 메서드가 호출될 때마다 화면을 다시 그리기 때문에 성능 이슈가 생김...... 
    ```javascript
    onClick = () => {
        this.setState(prevState => ({ count: prevState.count + 1 }));
        this.setState(prevState => ({ count: prevState.count + 1 }));
    }
    ```
 * 상태값 로직을 분리해서 사용하는 패턴
     ```jsx harmony
        const actions = {
            init() {
                return { count: 0 };
            },
            increment(state) {
                return { count: state.count + 1 };
            },
            decrement(state) {
                return { count: state.count - 1};
            }
        };
        class MyComponent extends React.Component {   
         state = action.init();
         onIncrement = () => {
           this.setState(actions.increment);
         };
         onDecrement = () => {
           this.setState(actions.decrement);
         }
        }
    ```
   
  * 호출 순서가 보장되는 setState 메서드
    * setState 메서드의 호출 순서대로 상탯값이 변경됨 -> result 는 항상 참.
          ```javascript
            class MyComponent extends React.component {
                state = {
                    count1: 0,
                    count2: 0
                };
                onClick = () => {
                    const { count1, count2 } = this.state;
                    this.setState({ count1: count1 + 1 });
                    // ...
                    this.setState({ count2: count2 + 1 });
                };
                render() {
                    const { count1, count2 } = this.state;
                    const result = count1 >= count2;
                }
            }
        ```
   
  * 콜백함수: setState의 두번째 매개변수는 처리가 끝났을 때 호출된다.
    * 처리된 시점을 알고싶을 때
    * 변경된 상태값 기반으로 다음 작업을 처리할 때
      ```javascript
        onClick = () => {
            this.setState({ count: 123 }, () => console.log('count is 123'));
        }
        ```
  
 * 불변 객체로 관리하는 속성값, 상태값
    * 속성값은 불변 : 변경 에러
    * 상태값도 불변으로 관리하면?
        * 복잡도 낮아짐
        * 렌더링 성능 향상
        
# 리액트 요소와 가상 돔
## 리액트 요소
* JSX -> createElement 함수
    ```jsx harmony
    const element = <a href="http://google.com">click here</a>;
    const element = React.createElement(
      'a',
      { href: 'http...'},
      'click here',
    );
    ```

### 리액트 요소의 구조
* createElement가 반환한 리액트 요소
   ```jsx harmony
   const element = (
       <a key="key1" style={{ width: 100 }} href="...">
           click here
       </a>
   )
   ```
* 리액트 요소를 로그로 출력한 결과
    ```jsx harmony
    const consoleLogResult = {
      type: 'a',                // 속성값 { 문자열: html 태그, 함수: 컴포넌트의 함수 }
      key: 'key1',
      ref: null,
      props: {
        href: '...',
        style: {
          width: 100,
        },
        children: 'click here',  
      },
      //...
    };
    ```
* JSX의 태그사이의 표현식
    ```jsx harmony
    const element = <h1>제 나이는 {20 + 4} 세 입니다 </h1>;
    console.log(element);
    const consoleLogResult = {
        type: 'h1',
        props: { children: ['제 나이는 ', 24, ' 세 입니다'] },
        // ...
    }
    ```
* 컴포넌트가 리액트 요소로 변경된 예
    ```jsx harmony
    function Title({ title, color }) {
      return <p style={{ color }}>{title}</p>;
    }
    const element = < Title title="hi" color="blue" />;
    console.log(element);
    const consoleLogResult = {
      type: Title,
      props: { title: 'hi', color: 'blue' },
      // ...
    }
    ```
 * 리액트 요소는 불변 객체
     ```jsx harmony
    const element = <a href="...">click</a>;
    element.type = 'b' // error
    ```
    ...
 * ReactDOM.render 함수를 주기적으로 호출하는 코드
    * 리액트가 새로운 리액트 요소르 받으면 이전의 리액트 요소와 비교해서 변경된 부분만 실제 돔에 반영된다.
     ```jsx harmony
    let seconds = 0;
    function update() {
      seconds += 1;
      const element = (
        <div>
          <h1>{seconds}</h1>
        </div>
      );
      ReactDOM.render(element, document.getElementById('root'));
    }
    
    setInterval(update, 1000);
    ```
   
 ### 리액트 요소가 돔 요소로 만들어지는 과정
 * 데이터 변경에 의한 화면 업데이트
    1. Render phase(reconciliation phase)
        * 가상돔을 이용하여 실제 돔의 변경 사항 파악
        * 리액트는 렌더링 할 때 마다 가상돔을 만든다. 
    2. commit phase
        * 실제 돔에 반영
 #### ReactDOM.render함수에 의해, 첫번째로 만들어지는 리액트 요소
     ```jsx harmony
    const initialElementTree = {
      type: Todo,
      props: {
        title: '...',
        desc: '...'
      },
      // ...
    }
    ```
* Todo 컴포넌트의 렌더 함수 호출 결과
    ```jsx harmony
   const elementTree = {
      type: 'div',
      props: {
        children: [
          type: Title,
          props: {title: '...'},
        ]
      } 
      //...
    }
  ```
    * 트리의 root 는 div 태그로 변경 됨.
    * 클래스형 컴포넌트는 인스턴스로 만들어 지고 리액트 내부에서 관리된다.
    * 리액트 요소 type 속성값이 문자열 이어야 트리가 실제 돔으로 만들어진다.
        * type 속성값이 문자열 이어야 HTML 태그로 변환 가능하다. 
        * 즉 모든 컴포넌트의 렌더 함수가 호출되어야 한다. 
* 가상돔
    * 실제 돔을 만들 수 있는 리액트 요소 트리
       
#### setState 메서드 호출 후 만들어진 리액트 요소 트리

# 생명주기 메서드
컴포넌트의 3 주기
1. 초기화 
2. 업데이트
3. 소멸

* 리액트의 각 단계에서 호출되는 생명 주기 메서드
![리액트의 각 단계에서 호출되는 생명 주기 메서드](./images/react cycle.jpeg)

## 초기화 단계
최초 컴포넌트 객체가 생성 될 때 한 번 수행
1. constructor()
2. static getDerivedStateFromProps()
3. render()
4. componentDidMount()

### constructor 메서드
* constructor 메서드의 기본구조
    ```jsx harmony
    class MyComponent extends React.Component {
      constructor(props) {
        super();
      }
    }
    ```
    * super 함수 호출 : React.Component 클래스의 constructor 메서드가 호출된다. 
* 초기 속성값으로부터 상태값을 만드는 코드
```jsx harmony
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      currentMovie: props.age < 10 ? "Q뽀로로" : "어벤져스",
    }
  }
}
```
    * 

## 업데이트 단계
초기화와 소멸 단계 사이 
컴포넌트 속성값/상태값 변경 시 수행
1. static getDerivedStateFromProps()
2. shouldComponentUpdate()
3. render()
4. getSnapshotBeforeUpdate()
5. componentDidUpdate()

## 소멸단계
1. componentWillUnmount()

## 예외 발생
1. static getDerivedStateFromError()
2. componentDidCatch()
